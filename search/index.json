[{"content":"MISC 签个到吧 Brainfuck 语言，\u0026rsquo;+-+-+-\u0026lsquo;无效操作会影响解释器运行，删除拿去解密即可 RE WARMUP 将前面的Execute改成 wscript.echo, 然后输入\n1 cscript chal.vbs \u0026gt;\u0026gt; output.txt 将执行结果重定向到 txt 文本中，提取 rc4 key 解密 然后 flag 里面内容 md 5 加密提交即可\nDragon Window 环境 LLVM clang 编写的 bc 文件，需要将它继续编译\n1 clang dragon.bc -o dragon 根据字符串定位到主函数，并进入比较函数： 有个常量 0x42F0E1EBA9EA3693，搜索发现是 CRC-64 算法 小端序存储，每次传入两个字节，直接让 ds 写个脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import struct def compute_crc(data): v5 = 0xFFFFFFFFFFFFFFFF for byte in data: v5 ^= (byte \u0026lt;\u0026lt; 56) \u0026amp; 0xFFFFFFFFFFFFFFFF for _ in range(8): if v5 \u0026amp; (1 \u0026lt;\u0026lt; 63): v5 = (v5 \u0026lt;\u0026lt; 1) ^ 0x42F0E1EBA9EA3693 else: v5 = (v5 \u0026lt;\u0026lt; 1) v5 \u0026amp;= 0xFFFFFFFFFFFFFFFF # 保持64位 v5 = ~v5 \u0026amp; 0xFFFFFFFFFFFFFFFF return v5 # 将十六进制数据按小端序转换为目标值 data = bytes.fromhex(\u0026#34;477B9F414EE363DCC6BFB2E7D4F81E039ED85F62BC2FD612E85557CCE1B6E883CC65B62AEBB17BFC6BD9622A1BCA829387C37376A0F8FFB1E1058E382716A80DB7AAD0E81AE6F19E4561F2E7D23F78920BE66FF5A17CC963AB3AB743B0A8D39B\u0026#34;) targets = [struct.unpack(\u0026#39;\u0026lt;Q\u0026#39;, data[i*8:(i+1)*8])[0] for i in range(12)] # 修正为小端序 flag = bytearray() for idx, target in enumerate(targets): found = None # 枚举所有可能的两个字节组合 for b0 in range(256): for b1 in range(256): candidate = bytes([b0, b1]) crc = compute_crc(candidate) if crc == target: found = candidate break if found: flag.extend(found) print(f\u0026#34;目标值 {idx+1}: {hex(target)} 匹配到: {found}\u0026#34;) break if not found: print(f\u0026#34;未找到匹配目标值: {hex(target)}\u0026#34;) exit() print(\u0026#34;Flag:\u0026#34;, flag.decode()) Moon 信息收集，定位到 pyd 字符串常量存放位置，找到目标字符串： Pyd 总共定义了两个函数 check_flag 和 xor_crypt, Check_flag 函数调用了 xor_crypt 函数，因此只需要调试 check_flag 函数即可。 Pyd 函数真正的入口：\n这里函数逻辑运算入口：\n直接到比较处下断点：\n查看 v45 和 v10 处，发现一个为目标字符，另一个应该加密产生的字符，结合函数名，猜测该字符为异或所产生，只需要将输入字符 byte 改为 0 即可得到密钥 定位到此处，将 rax 处的输入字符修改为 0 byte 得到密钥：\n解密：\n","date":"2025-04-08T00:54:43+08:00","permalink":"https://honestlin.top/p/2025-xyctf-wp/","title":"2025 XYCTF WP"},{"content":"溯源排查 溯源排查 -1 仿真后直接进入系统抓包\n溯源排查-2 用端口去定位进程程序, 抓包可以知道网络包为 udp 溯源排查 -3 检查服务 发现可疑服务 systemd-journaled. Service\n溯源排查-4 R-studio 找到 nacos 溯源排查-5 在漏洞库搜索 溯源排查-6 在 tmp 找到 复制名称到游览器搜索： 和黑客去Battle把！ 从txt文档中拿到密钥后，登录界面，跟对面砍价 窃密排查 窃密排查-1 启动容器后，连接靶机。\n输入：\nfind . type -f，全局搜索修改的文件 然后cat megacmdserver.log文件\n找到对应的邮箱账号\n窃密排查-2 将找到的邮箱账号拿去查询 然后到 yopmail 进入邮箱，找到恢复密钥 在共享项目找到 flag\n窃密排查-3 点开聊天： 用给的密钥登录： 登录不上\u0026hellip;.，估计是过期了，复现失败。\n2503 逆向 将exe拖入 ida分析\n分析代码可知，代码前部分设置了一个随机数，根据随机数从字符集取出：\n初步判断这个加密器是通过rc4加密，找密钥。 前面出现了一个随机字符集，猜测密钥是根据开机时间生成的，所以可以通过对密钥进行爆破。\n爆破脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 from multiprocessing import Pool with open(\u0026#34;flag.txt.freefix\u0026#34;, \u0026#34;rb\u0026#34;) as f: ciphertext = f.read() first_4_bytes = ciphertext[:4] charset = \u0026#34;qa0wserdf1tg9yuhjio2pklz8xbvcn4mPL7JKOIHUG3YTF6DSREAWQZX5MNCBV\u0026#34; def generate_key(seed): key = [] state = seed for _ in range(16): state = (state * 214013 + 2531011) \u0026amp; 0xFFFFFFFF # LCG算法 rand_val = (state \u0026gt;\u0026gt; 16) \u0026amp; 0x7FFF key_char = charset[rand_val % 62] key.append(ord(key_char)) return bytes(key) def rc4_decrypt_first_4(key, ciphertext): S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] i = j = 0 keystream = [] for _ in range(4): i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] keystream.append(S[(S[i] + S[j]) % 256]) decrypted = bytes([c ^ k for c, k in zip(ciphertext, keystream)]) return decrypted def check_seed(seed): key = generate_key(seed) decrypted = rc4_decrypt_first_4(key, first_4_bytes) if decrypted == b\u0026#34;flag\u0026#34;: return seed, key return None if __name__ == \u0026#34;__main__\u0026#34;: start_seed = 0 end_seed = 3000000 with Pool(processes=8) as pool: results = pool.imap_unordered(check_seed, range(start_seed, end_seed)) for result in results: if result: seed, key = result print(f\u0026#34;找到种子: {seed}\u0026#34;) print(f\u0026#34;密钥: {bytes(key).decode()}\u0026#34;) break ","date":"2025-03-31T21:42:09+08:00","permalink":"https://honestlin.top/p/solar%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%AC%E7%9B%8A%E6%9C%88%E8%B5%9B-3%E6%9C%88/","title":"solar应急响应公益月赛-3月"}]