[{"content":"最难崩的一集，头一次见到 web, pwn 是静态 flag，re ，MISC 是动态 flag 的比赛了。\n1 SP 签到题\n1 upx -d sp.exe 脱壳 然后在 incorrect 比较函数处下断点就可以得到 flag 了\n2 我爱看小品 pyc 逆向，运行程序出现报错，baidu 一下：\n发现是个 pyinstaller 打包的程序。\n拿 pyinstxtractor 解包程序，发现有个 something, pyz 加密包\n拿 uncompyle 6 梭一下，引用了 mypy, yourpy，这两个文件都在 pyz 加密包里面，因此需要解开\npython 3.11 一直解不出 pyc. encrypted 文件，因此在python 3.8 环境用 pyinstxtractor-ng 解包程序，拿到 key (在 pyimod 00_crypto_key. pyc 里面)，在 pyinstxtractor-ng github 上可以找到对应版本的解密脚本，解密：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #!/usr/bin/env python3 # For pyinstaller \u0026gt;= 4.0 import tinyaes import zlib CRYPT_BLOCK_SIZE = 16 # key obtained from pyimod00_crypto_key key = bytes(\u0026#39;yibaibayibei1801\u0026#39;, \u0026#39;utf-8\u0026#39;) inf = open(\u0026#39;mypy.pyc.encrypted\u0026#39;, \u0026#39;rb\u0026#39;) # encrypted file input outf = open(\u0026#39;mypy.pyc\u0026#39;, \u0026#39;wb\u0026#39;) # output file # Initialization vector iv = inf.read(CRYPT_BLOCK_SIZE) cipher = tinyaes.AES(key, iv) # Decrypt and decompress plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read())) # Write pyc header # The header below is for Python 3.8 outf.write(b\u0026#39;\\x55\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\u0026#39;) # Write decrypted data outf.write(plaintext) inf.close() outf.close() 然后再梭 mypy. pyc, yourpy. pyc：\n字符处理，解密即可。\n3 三进制战争 frida 一把梭，解密脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import frida import sys current_char_index = 32 def on_message(message, data): if message[\u0026#39;type\u0026#39;] == \u0026#39;send\u0026#39;: # 获取原始返回值 payload = message[\u0026#39;payload\u0026#39;] if isinstance(payload, dict) and \u0026#39;char\u0026#39; in payload and \u0026#39;result\u0026#39; in payload: char = payload[\u0026#39;char\u0026#39;] result = payload[\u0026#39;result\u0026#39;] print(f\u0026#34;[+] 字符: {char}, 方法返回值: {result}\u0026#34;) else: print(f\u0026#34;[+] 方法返回值: {payload}\u0026#34;) else: print(message) jscode = \u0026#34;\u0026#34;\u0026#34; Java.perform(function () { var MainActivity = Java.use(\u0026#39;com.example.mobile02.MainActivity\u0026#39;); Java.choose(\u0026#39;com.example.mobile02.MainActivity\u0026#39;, { onMatch: function(instance) { try { var target = \u0026#34;002102001221012212020121001200001221\u0026#34;; var a = \u0026#34;\u0026#34;; var sum = 1; var found = false; while (!found \u0026amp;\u0026amp; (sum * 6) \u0026lt;= target.length) { let matched = false; for (let k = 32; k \u0026lt;= 126; k++) { let str3 = a + String.fromCharCode(k); let str1 = instance.stringFromJNl(\u0026#34;da156b6a06bcd826c60f07bfe2136d87\u0026#34;, str3); if (str1 == target.substring(0, sum * 6)) { console.log(\u0026#34;已匹配: \u0026#34; + str1); a = str3; sum += 1; matched = true; if (str1 == target) { found = true; console.log(\u0026#34;最终匹配成功: \u0026#34; + a); } break; // 找到本轮字符，进入下一轮 } } if (!matched) { console.error(\u0026#34;未找到匹配字符，当前a: \u0026#34; + a); break; } } } catch (e) { console.error(\u0026#34;调用失败: \u0026#34; + e); } }, onComplete: function() {} }); }); \u0026#34;\u0026#34;\u0026#34; device = frida.get_usb_device() try: session = device.attach(\u0026#34;mobile02\u0026#34;) except frida.ProcessNotFoundError: print(\u0026#34;[-] 应用未运行！请先启动应用\u0026#34;) sys.exit(1) script = session.create_script(jscode) script.on(\u0026#39;message\u0026#39;, on_message) script.load() sys.stdin.read() 4 Encode apk 损坏且没有签名，把 dex 拿出来反编译：\nflag 分为两部分，后半部分在 JNI nativeCheckLast 处，前半部分在 JNI nativeCheckFormat。apk 损坏动调不了，只能拉 so 硬造了。nativeCheckLast 是一个简单的字符置换\n将密文加 3 就可以得到后半部分的 flag\n前半部分是一个异或加 base 编码： 密文在此处： 解密：\n最终 ISCC{Slyth3r! n_L@bYrinth }\n5 冗余的代码 一个没符号的程序，懒得恢复，硬调 简单分析一下主函数，是一个 5 x 5 的迷宫，因此只要让输入最终为迷宫的正确路径即可得到 flag 迷宫：*11110100001010000101111# 正确路径:020202040401010404020202\n用 IDA 插件发现有个 xxtea 加密。\n在此处打个断点，看看输入的值在此之前有无进行处理：\n此处输入的 080808 被转换为 02030405，说明前面对输入字符进行了处理，将 02030405 输入，发现变回了 080808，说明是一个 xor 加密\n这里是一个迷宫路径移动的逻辑代码，需要让输入字符最终得到正确走完迷宫，迷宫已知，因此输入字符处理后的字符串为 020202040401010404020202, 也就是 xxtea 后的密文。\n然后到字符最终检验处看输入值是否还有变化\n没有变化，至此该程序已分析完毕。\n6 睡蕉小猴 安装 apk 运行后发现有个视频一直进不去，需要 hook 对应的函数进行跳过。\n接着分析主函数发现有个 getsnowkey () 函数，调用它返回 snow key（我一直以为这玩意是自定义的函数，原来是一个隐写，在这卡了半天）\nfrida 脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import frida import sys rdev = frida.get_remote_device() pid = rdev.spawn([\u0026#34;com.example.mobile03\u0026#34;]) session = rdev.attach(pid) scr = \u0026#34;\u0026#34;\u0026#34; Java.perform(function () { // Hook MainActivity.showAd 方法 var MainActivity = Java.use(\u0026#34;com.example.mobile03.MainActivity\u0026#34;); var showAd = MainActivity.showAd; showAd.implementation = function () { // 修改 showAd 方法的实现，不执行原方法 }; var MainActivity = Java.use(\u0026#34;com.example.mobile03.MainActivity\u0026#34;); var check = MainActivity.check; check.implementation = function(str){ console.log(str); var result = this.check(str); console.log(result); return result; } // Hook MainActivity.Jformat 方法 var MainActivity = Java.use(\u0026#34;com.example.mobile03.MainActivity\u0026#34;); var Jformat = MainActivity.Jformat; Jformat.implementation = function (str1, str2) { console.log(str1, str2); var result = this.Jformat(str1, str2); console.log(result); return result; }; }); \u0026#34;\u0026#34;\u0026#34; script = session.create_script(scr) def on_message(message, data): print(message, data) script.on(\u0026#34;message\u0026#34;, on_message) script.load() rdev.resume(pid) sys.stdin.read() hook 返回的 key:\n在资源文件中找到 snow 隐写的 txt，解密得到一串 16 进制数。\n接着分析 Jformat 方法，发现它调用了一个 isFlag 方法，全局字符串搜索，定位到相关函数：\n有公钥和私钥，初步判断为 rsa 加密，target 就是要解密的文本，既然要解密，因此我们只需要拿到私钥就可以了，同样定位字符串找到初始定义。\nfrida Hook 不住，应该缺少了环境，拿 unidbg 补环境去跑一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 package ISCC; import com.alibaba.fastjson.util.IOUtils; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.debugger.Debugger; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.*; import com.github.unidbg.memory.Memory; import java.io.File; import java.io.FileNotFoundException; public class mobile extends AbstractJni { private final AndroidEmulator emulator; private final VM vm; private final Module module; private final DvmClass swan, pig; private final boolean logging; public mobile(boolean logging) throws FileNotFoundException { this.logging = logging; // 创建模拟器实例 emulator = AndroidEmulatorBuilder.for64Bit() .setProcessName(\u0026#34;com.example.test\u0026#34;) .addBackendFactory(new Unicorn2Factory(true)) .build(); // 模拟器的内存操作接口 final Memory memory = emulator.getMemory(); memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析 // 创建 Android 虚拟机 vm = emulator.createDalvikVM(new File(\u0026#34;\u0026#34;));//你的文件路径 vm.setVerbose(logging); // 设置是否打印 Jni 调用细节 vm.setJni(this); DalvikModule dm = vm.loadLibrary(new File(\u0026#34;\u0026#34;), false);//你的文件路径 module = dm.getModule(); Debugger attach = emulator.attach(); attach.addBreakPoint(module.base + 0x0000000000021B04); dm.callJNI_OnLoad(emulator); // 手动执行 JNI_OnLoad 函数 swan = vm.resolveClass(\u0026#34;com/example/mobile03/swan\u0026#34;); pig = vm.resolveClass(\u0026#34;pig\u0026#34;); } public mobile(AndroidEmulator emulator, VM vm, Module module, DvmClass mMainActivity, DvmClass swan, DvmClass pig, boolean logging) { this.emulator = emulator; this.vm = vm; this.module = module; this.swan = swan; this.pig = pig; this.logging = logging; } void destroy() { IOUtils.close(emulator); if (logging) { System.out.println(\u0026#34;destroy\u0026#34;); } } public static void main(String[] args) throws Exception { mobile test = new mobile(true); test.encrypt(); test.destroy(); } boolean encrypt() { String text = \u0026#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34; + \u0026#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34; + \u0026#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34; + \u0026#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34; + \u0026#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34; + \u0026#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34;; String res = String.valueOf(swan.callStaticJniMethodObject(emulator, \u0026#34;getPvKey()Ljava/lang/String;\u0026#34;, text)); return true; } } 将得到密钥流 xor 回输入的字符，然后再与 snow 隐写的数据进行解密，得到一串 rsa 私钥\n拿去 rsa 解密\n晕，这玩意是 11 位后面的 flag，还有一段，源代码看不出有啥，我直接字符串大法（😀）。\n一个简单字符替换，最终 ISCC{Z5$uK7w2#JkQ}\n","date":"2025-05-07T21:53:56+08:00","permalink":"http://localhost:1313/p/2025-iscc-wp/","title":"2025 ISCC WP"},{"content":"MISC 签个到吧 Brainfuck 语言，\u0026rsquo;+-+-+-\u0026lsquo;无效操作会影响解释器运行，删除拿去解密即可 RE WARMUP 将前面的Execute改成 wscript.echo, 然后输入\n1 cscript chal.vbs \u0026gt;\u0026gt; output.txt 将执行结果重定向到 txt 文本中，提取 rc4 key 解密 然后 flag 里面内容 md 5 加密提交即可\nDragon Window 环境 LLVM clang 编写的 bc 文件，需要将它继续编译\n1 clang dragon.bc -o dragon 根据字符串定位到主函数，并进入比较函数： 有个常量 0x42F0E1EBA9EA3693，搜索发现是 CRC-64 算法 小端序存储，每次传入两个字节，直接让 ds 写个脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import struct def compute_crc(data): v5 = 0xFFFFFFFFFFFFFFFF for byte in data: v5 ^= (byte \u0026lt;\u0026lt; 56) \u0026amp; 0xFFFFFFFFFFFFFFFF for _ in range(8): if v5 \u0026amp; (1 \u0026lt;\u0026lt; 63): v5 = (v5 \u0026lt;\u0026lt; 1) ^ 0x42F0E1EBA9EA3693 else: v5 = (v5 \u0026lt;\u0026lt; 1) v5 \u0026amp;= 0xFFFFFFFFFFFFFFFF # 保持64位 v5 = ~v5 \u0026amp; 0xFFFFFFFFFFFFFFFF return v5 # 将十六进制数据按小端序转换为目标值 data = bytes.fromhex(\u0026#34;477B9F414EE363DCC6BFB2E7D4F81E039ED85F62BC2FD612E85557CCE1B6E883CC65B62AEBB17BFC6BD9622A1BCA829387C37376A0F8FFB1E1058E382716A80DB7AAD0E81AE6F19E4561F2E7D23F78920BE66FF5A17CC963AB3AB743B0A8D39B\u0026#34;) targets = [struct.unpack(\u0026#39;\u0026lt;Q\u0026#39;, data[i*8:(i+1)*8])[0] for i in range(12)] # 修正为小端序 flag = bytearray() for idx, target in enumerate(targets): found = None # 枚举所有可能的两个字节组合 for b0 in range(256): for b1 in range(256): candidate = bytes([b0, b1]) crc = compute_crc(candidate) if crc == target: found = candidate break if found: flag.extend(found) print(f\u0026#34;目标值 {idx+1}: {hex(target)} 匹配到: {found}\u0026#34;) break if not found: print(f\u0026#34;未找到匹配目标值: {hex(target)}\u0026#34;) exit() print(\u0026#34;Flag:\u0026#34;, flag.decode()) Moon 信息收集，定位到 pyd 字符串常量存放位置，找到目标字符串：\nPyd 总共定义了两个函数 check_flag 和 xor_crypt, Check_flag 函数调用了 xor_crypt 函数，因此只需要调试 check_flag 函数即可。\nPyd 函数真正的入口：\n这里函数逻辑运算入口：\n直接到比较处下断点：\n查看 v45 和 v10 处，发现一个为目标字符，另一个应该加密产生的字符，结合函数名，猜测该字符为异或所产生，只需要将输入字符 byte 改为 0 即可得到密钥 定位到此处，将 rax 处的输入字符修改为 0 byte 得到密钥：\n解密：\n","date":"2025-04-08T00:54:43+08:00","permalink":"http://localhost:1313/p/2025-xyctf-wp/","title":"2025 XYCTF WP"},{"content":"溯源排查 溯源排查 -1 仿真后直接进入系统抓包\n溯源排查-2 用端口去定位进程程序, 抓包可以知道网络包为 udp 溯源排查 -3 检查服务 发现可疑服务 systemd-journaled. Service\n溯源排查-4 R-studio 找到 nacos 溯源排查-5 在漏洞库搜索 溯源排查-6 在 tmp 找到 复制名称到游览器搜索： 和黑客去Battle把！ 从txt文档中拿到密钥后，登录界面，跟对面砍价 窃密排查 窃密排查-1 启动容器后，连接靶机。\n输入：\nfind . type -f，全局搜索修改的文件 然后cat megacmdserver.log文件\n找到对应的邮箱账号\n窃密排查-2 将找到的邮箱账号拿去查询 然后到 yopmail 进入邮箱，找到恢复密钥 在共享项目找到 flag\n窃密排查-3 点开聊天： 用给的密钥登录： 登录不上\u0026hellip;.，估计是过期了，复现失败。\n2503 逆向 将exe拖入 ida分析\n分析代码可知，代码前部分设置了一个随机数，根据随机数从字符集取出：\n初步判断这个加密器是通过rc4加密，找密钥。 前面出现了一个随机字符集，猜测密钥是根据开机时间生成的，所以可以通过对密钥进行爆破。\n爆破脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 from multiprocessing import Pool with open(\u0026#34;flag.txt.freefix\u0026#34;, \u0026#34;rb\u0026#34;) as f: ciphertext = f.read() first_4_bytes = ciphertext[:4] charset = \u0026#34;qa0wserdf1tg9yuhjio2pklz8xbvcn4mPL7JKOIHUG3YTF6DSREAWQZX5MNCBV\u0026#34; def generate_key(seed): key = [] state = seed for _ in range(16): state = (state * 214013 + 2531011) \u0026amp; 0xFFFFFFFF # LCG算法 rand_val = (state \u0026gt;\u0026gt; 16) \u0026amp; 0x7FFF key_char = charset[rand_val % 62] key.append(ord(key_char)) return bytes(key) def rc4_decrypt_first_4(key, ciphertext): S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] i = j = 0 keystream = [] for _ in range(4): i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] keystream.append(S[(S[i] + S[j]) % 256]) decrypted = bytes([c ^ k for c, k in zip(ciphertext, keystream)]) return decrypted def check_seed(seed): key = generate_key(seed) decrypted = rc4_decrypt_first_4(key, first_4_bytes) if decrypted == b\u0026#34;flag\u0026#34;: return seed, key return None if __name__ == \u0026#34;__main__\u0026#34;: start_seed = 0 end_seed = 3000000 with Pool(processes=8) as pool: results = pool.imap_unordered(check_seed, range(start_seed, end_seed)) for result in results: if result: seed, key = result print(f\u0026#34;找到种子: {seed}\u0026#34;) print(f\u0026#34;密钥: {bytes(key).decode()}\u0026#34;) break ","date":"2025-03-31T21:42:09+08:00","permalink":"http://localhost:1313/p/solar%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%AC%E7%9B%8A%E6%9C%88%E8%B5%9B-3%E6%9C%88/","title":"solar应急响应公益月赛-3月"}]