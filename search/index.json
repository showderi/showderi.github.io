[{"content":"溯源排查 溯源排查 -1 仿真后直接进入系统抓包\n溯源排查-2 用端口去定位进程程序, 抓包可以知道网络包为 udp 溯源排查 -3 检查服务 发现可疑服务 systemd-journaled. Service\n溯源排查-4 R-studio 找到 nacos 溯源排查-5 在漏洞库搜索 溯源排查-6 在 tmp 找到 复制名称到游览器搜索： 和黑客去Battle把！ 从txt文档中拿到密钥后，登录界面，跟对面砍价 窃密排查 窃密排查-1 启动容器后，连接靶机。\n输入：\nfind . type -f，全局搜索修改的文件 然后cat megacmdserver.log文件\n找到对应的邮箱账号\n窃密排查-2 将找到的邮箱账号拿去查询 然后到 yopmail 进入邮箱，找到恢复密钥 在共享项目找到 flag\n窃密排查-3 点开聊天： 用给的密钥登录： 登录不上\u0026hellip;.，估计是过期了，复现失败。\n2503 逆向 将exe拖入 ida分析\n分析代码可知，代码前部分设置了一个随机数，根据随机数从字符集取出：\n初步判断这个加密器是通过rc4加密，找密钥。 前面出现了一个随机字符集，猜测密钥是根据开机时间生成的，所以可以通过对密钥进行爆破。\n爆破脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 from multiprocessing import Pool with open(\u0026#34;flag.txt.freefix\u0026#34;, \u0026#34;rb\u0026#34;) as f: ciphertext = f.read() first_4_bytes = ciphertext[:4] charset = \u0026#34;qa0wserdf1tg9yuhjio2pklz8xbvcn4mPL7JKOIHUG3YTF6DSREAWQZX5MNCBV\u0026#34; def generate_key(seed): key = [] state = seed for _ in range(16): state = (state * 214013 + 2531011) \u0026amp; 0xFFFFFFFF # LCG算法 rand_val = (state \u0026gt;\u0026gt; 16) \u0026amp; 0x7FFF key_char = charset[rand_val % 62] key.append(ord(key_char)) return bytes(key) def rc4_decrypt_first_4(key, ciphertext): S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] i = j = 0 keystream = [] for _ in range(4): i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] keystream.append(S[(S[i] + S[j]) % 256]) decrypted = bytes([c ^ k for c, k in zip(ciphertext, keystream)]) return decrypted def check_seed(seed): key = generate_key(seed) decrypted = rc4_decrypt_first_4(key, first_4_bytes) if decrypted == b\u0026#34;flag\u0026#34;: return seed, key return None if __name__ == \u0026#34;__main__\u0026#34;: start_seed = 0 end_seed = 3000000 with Pool(processes=8) as pool: results = pool.imap_unordered(check_seed, range(start_seed, end_seed)) for result in results: if result: seed, key = result print(f\u0026#34;找到种子: {seed}\u0026#34;) print(f\u0026#34;密钥: {bytes(key).decode()}\u0026#34;) break ","date":"2025-03-31T21:42:09+08:00","permalink":"http://localhost:1313/p/solar%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%85%AC%E7%9B%8A%E6%9C%88%E8%B5%9B-3%E6%9C%88/","title":"solar应急响应公益月赛-3月"}]